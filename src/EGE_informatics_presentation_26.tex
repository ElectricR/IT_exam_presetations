\documentclass{beamer}

\usepackage{minted}

\usepackage[russian]{babel}

\usepackage{fontspec}
\defaultfontfeatures{Ligatures=TeX}
\setmainfont{OpenSans}
\setsansfont{OpenSans}
\setmonofont{FreeSerif}

\usetheme{Copenhagen}
\usecolortheme{beaver}

\title[Задание 26]{ЕГЭ по Информатике 2021}
\subtitle{Задание 26}
\author{Роман Чулков}
\institute{СПбГУТ}

\begin{document}

\frame{\titlepage}

\begin{frame}

    \frametitle{Условие задачи}

    Системный администратор раз в неделю создаёт архив пользовательских файлов. Однако объём диска, куда он помещает архив, может быть меньше, чем суммарный объём архивируемых файлов. Известно, какой объём занимает файл каждого пользователя. 

    По заданной информации об объёме файлов пользователей и свободном объёме на архивном диске определите максимальное число пользователей, чьи файлы можно сохранить в архиве, а также максимальный размер имеющегося файла, который может быть сохранён в архиве, при условии, что сохранены файлы максимально возможного числа пользователей. 

\end{frame}

\begin{frame}

    \frametitle{Входные данные}

    В первой строке входного файла находятся два числа: S — размер свободного места на диске (натуральное число, не превышающее 10 000) и N — количество пользователей (натуральное число, не превышающее 3000). В следующих N строках находятся значения объёмов файлов каждого пользователя (все числа натуральные, не превышающие 100), каждое в отдельной строке.

\end{frame}

\begin{frame}

    \frametitle{Выходные данные}

    Запишите в ответе два числа: сначала наибольшее число пользователей, чьи файлы могут быть помещены в архив, затем максимальный размер имеющегося файла, который может быть сохранён в архиве, при условии, что сохранены файлы максимально возможного числа пользователей.
    
\end{frame}

\begin{frame}

    \frametitle{Пример}

    \begin{block}{Пример входного файла}

        100 4

        80

        30

        50

        40

    \end{block}

    При таких исходных данных можно сохранить файлы максимум двух пользователей. Возможные объёмы этих двух файлов \alert{30 и 40}, \alert{30 и 50} или \alert{40 и 50}. Наибольший объём файла из перечисленных пар — \alert{50}.

    \begin{alertblock}{Ответ}

        2 50

    \end{alertblock}

\end{frame}

\begin{frame}

    \frametitle{Подход к решению}

    Разделим решение на 2 подзадачи - нахождение максимального числа пользователей, файлы которых сможет содержать архивный диск, и нахождение максимального размера файла, при условии хранения максимального количества файлов.

\end{frame}

\begin{frame}

    \frametitle{Подсчет файлов}

    Для нахождения максимального количества хранимых файлов, воспользуемся \alert{жадной} стратегией.

    \pause

    \begin{alertblock}{Жадная стратегия}

        Пусть $S$ - оптимальное решение задачи. Тогда файл с наименьшим размером всегда входит в оптимальное решение.

    \end{alertblock}

    \pause

    \begin{block}{Доказательство}

        Предположим, что $S_1$ - оптимальное заполнение архивного диска, которое не включает файл минимального размера. Заменим любой файл из $S_1$ на минимальный. Получим новое заполнение диска $S_2 < S_1$, что противоречит с нашим предположением. 

    \end{block}

\end{frame}

\begin{frame}

    \frametitle{Алгоритм подсчета файлов}

    Пусть $x_1, x_2, ... , x_N$ - множество файлов пользователей, и $S_0$ - изначальный объём архивного диска.

    Заметим, что сделав жадный шаг и добавив на архивный диск файл $i$, мы получим новую подзадачу, в которой множество файлов пользователей равно $\{x_1, x_2, ... , x_N\} \setminus x_i$ и объём архивного диска $S_1 = S_0 - x_i$. 

    \pause

    \begin{alertblock}{Алгоритм}

        {\footnotesize

        \begin{enumerate}

            \item Отсортируем файлы пользователей по возрастанию.

            \item Если множество файлов пусто, или объём архивного диска меньше минимального файла, закончим вычисления.

            \item Изымем первый элемент массива файлов и добавим в ответ.

            \item Вычтем из объёма архивного диска вес текущего файла.

            \item Перейдем на шаг 2.

        \end{enumerate}
        
        }

    \end{alertblock}

\end{frame}

\begin{frame}

    \frametitle{Вычисление максимального файла}

    { \footnotesize

    Для вычисления максимального объема файла, при условии хранения максимального количества файлов пользователей, так же воспользуемся \alert{жадной} стратегией.

    \pause

    \begin{alertblock}{Жадная стратегия}

        Пусть $S_0$ - оптимальное решение из $N$ файлов на множестве $X$, при объеме диска $S$. Тогда в множестве добавленных файлов присутствует файл максимального размера, который может поместиться в объем $S - \sum{Y}$, где $Y$ - наименьшие $N - 1$ файлов в множестве $X$. Назовем такой файл \emph{ключевым}.

    \end{alertblock}

    \pause

    \begin{block}{Доказательство}

        Пусть $S_1$ - оптимальное решение, в которое не входит \emph{ключевой} файл. Заменим $N - 1$ файлов, входящих в решение $S_0$ на множество $Y$. Тогда множество $S_1 \setminus Y$ состоит из одного файла из множества $X \setminus Y$, но меньшего \emph{ключевого} файла, что является противоречием с тем, что $S_1$ является отпимальным решением, т.к. мы можем заменить этот файл на ключевой, получив новое решение из $N$ файлов, но с большим максимальным файлом.

    \end{block}

    }

\end{frame}

\begin{frame}

    \frametitle{Алгоритм}

    Прежде всего решим подзадачу нахождения какого-то решения, содержащего оптимальное количество файлов, с помощью алгоритма, рассмотренного ранее.

    \pause

    \begin{alertblock}{Алгоритм}

        \begin{enumerate}

            \item Изымем из отсортированного массива файлов следующий элемент.

            \item Попробуем добавить его в решение вместо максимального файла.

            \item Если у нас не получилось, то закончим выполнение алгоритма, иначе вернемся на шаг 1.
        \end{enumerate}
        
    \end{alertblock}

\end{frame}

\begin{frame}

    \frametitle{Сортировка}

    Для решения задачи нам потребуется реализовать функцию сортировки массива. Так как мы минимизируем время выполнения задания, а не время работы алгоритма, напишем \alert{сортировку пузырьком}.

    \pause

    \begin{block}{Принцип работы}

        Сделаем проход по массиву, попарно сравнивая соседние элементы. Если \emph{больший} элемент находится левее \emph{меньшего}, то обменяем их местами. Не сложно заметить, что после такого прохода по массиву, наибольший элемент окажется в самом конце массива.

        Пройдясь по массиву $N - 1$ раз, на каждой итерации мы перенесем самый большой элемент в еще не отсортированной части на свое место, в результате чего получим отсортированный по возрастанию массив.

    \end{block}


\end{frame}

\begin{frame}[fragile]

    \frametitle{Пример кода на Python}

    Реализуем алгоритм сортировки пузырьком в виде функции.

    \inputminted[frame=single, fontsize=\small]{python}{src/task_26/sort.py}

\end{frame}

\begin{frame}[fragile]

    \frametitle{Пример кода на Python}

    Подготовим всё необходимое для решения.

    \inputminted[frame=single, fontsize=\small]{python}{src/task_26/declaration.py}

\end{frame}

\begin{frame}[fragile]

    \frametitle{Пример кода на Python}

    Реализуем алгоритм и вывод ответа

    \inputminted[frame=single, fontsize=\footnotesize]{python}{src/task_26/solution.py}

\end{frame}

\end{document}
